Index: app/src/main/java/com/hansung/sherpa/navigation/Navigation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hansung.sherpa.navigation\r\n\r\nimport android.util.Log\r\nimport androidx.core.content.ContextCompat\r\nimport com.hansung.sherpa.MainActivity\r\nimport com.hansung.sherpa.R\r\nimport com.hansung.sherpa.convert.Convert\r\nimport com.hansung.sherpa.convert.LegRoute\r\nimport com.hansung.sherpa.convert.PathType\r\nimport com.hansung.sherpa.deviation.RouteControl\r\nimport com.hansung.sherpa.deviation.Section\r\nimport com.hansung.sherpa.transit.TransitManager\r\nimport com.hansung.sherpa.transit.TransitRouteRequest\r\nimport com.naver.maps.geometry.LatLng\r\nimport com.naver.maps.geometry.Utmk\r\nimport com.naver.maps.map.NaverMap\r\nimport com.naver.maps.map.overlay.PathOverlay\r\nimport kotlinx.coroutines.delay\r\n\r\nclass Navigation {\r\n    private var startLatLng: LatLng = LatLng(0.0, 0.0)\r\n    var endLatLng: LatLng = LatLng(0.0, 0.0)\r\n    private var routeRequest: TransitRouteRequest = setRouteRequest(startLatLng, endLatLng)\r\n    private var pathOverlayList:MutableList<PathOverlay> = mutableListOf()\r\n    lateinit var naverMap: NaverMap\r\n    lateinit var mainActivity: MainActivity\r\n    lateinit var routeControl: RouteControl\r\n\r\n    // 반드시 지울 것!! 좌표 찾기 대신 넣는 임시 값\r\n    // [개발]: 시작, 도착 좌표\r\n\r\n    // KJH\r\n        private val tempStartLatLng = LatLng(37.642636, 127.835763)\r\n        val tempEndLatLng = LatLng(37.627448, 126.829388)\r\n\r\n    //KMJ\r\n//    private val tempStartLatLng = LatLng(37.5004198786564, 127.126936754911) // 인천공항 버스 정류소(오금동)\r\n//    val tempEndLatLng = LatLng(37.6134436427887, 126.926493082645) // 은평청여울수영장\r\n\r\n\r\n    // 반드시 지울 것!!\r\n    \r\n    // 경로 탐색\r\n    fun getTransitRoutes(start: String, end: String){\r\n        // 검색어 기반 좌표 검색\r\n        /**\r\n         * 미완성이라 주석처리\r\n         * val SL = SearchLocation()\r\n         * startLatLng = SL.searchLatLng(start)\r\n         * endLatLng = SL.searchLatLng(end)\r\n        **/\r\n        \r\n        // 좌표 기반 경로 검색\r\n        routeRequest = setRouteRequest(tempStartLatLng, tempEndLatLng)\r\n        val transitRouteResponse = TransitManager(mainActivity).getTransitRoutes2(routeRequest)\r\n        val transitRoutes = Convert().convertToRouteMutableLists(transitRouteResponse)\r\n        val transitRoute = transitRoutes[0]\r\n        \r\n        // 경로 그리기\r\n        drawRoute(transitRoute)\r\n\r\n        // 기타\r\n        //---------- <김명준> 리팩토링 필요 ----------\r\n        routeControl.route = Convert().convertLegRouteToLatLng(transitRoute)\r\n        routeControl.nowSection = 0\r\n        routeControl.from = Utmk.valueOf(routeControl.route[routeControl.nowSection])\r\n        routeControl.to = Utmk.valueOf(routeControl.route[routeControl.nowSection+1])\r\n        routeControl.froms = routeControl.findIntersectionPoints(routeControl.from)\r\n        routeControl.tos = routeControl.findIntersectionPoints(routeControl.to)\r\n        //---------- 여기까지 ----------\r\n    }\r\n\r\n    // 경로 요청 값 만들기\r\n    private fun setRouteRequest(startLatLng: LatLng, endLatLng: LatLng):TransitRouteRequest {\r\n        return TransitRouteRequest(\r\n            startX = startLatLng.longitude.toString(),\r\n            startY = startLatLng.latitude.toString(),\r\n            endX = endLatLng.longitude.toString(),\r\n            endY = endLatLng.latitude.toString(),\r\n            lang = 0,\r\n            format = \"json\",\r\n            count = 1\r\n        )\r\n    }\r\n\r\n    // 경로를 지우는 함수\r\n    private fun clearRoute() {\r\n        pathOverlayList.forEach { it.map = null }\r\n        pathOverlayList = mutableListOf()\r\n    }\r\n\r\n    // 재탐색 후 경로를 그리는 함수\r\n    fun redrawRoute(location:LatLng, endLatLng: LatLng) {\r\n        // 경로 초기화\r\n        clearRoute()\r\n        // 좌표 기반 경로 검색\r\n        routeRequest = setRouteRequest(location, endLatLng)\r\n        // 요청 좌표 기반 경로 검색\r\n        val transitRouteResponse = TransitManager(mainActivity).getTransitRoutes2(routeRequest)\r\n        val transitRoutes = Convert().convertToRouteMutableLists(transitRouteResponse)\r\n        val transitRoute = transitRoutes[0]\r\n        // 경로 그리기\r\n        drawRoute(transitRoute)\r\n        // 기타\r\n        routeControl.route = Convert().convertLegRouteToLatLng(transitRoute)\r\n        routeControl.nowSection = 0\r\n    }\r\n    \r\n    // 경로를 그리는 함수\r\n    private fun drawRoute(transitRoute: MutableList<LegRoute>) {\r\n        for (i in transitRoute){\r\n            val pathOverlay = PathOverlay().also {\r\n                it.coords = Convert().convertCoordinateToLatLng(i.coordinates)\r\n                it.width = 10\r\n                when(i.pathType){\r\n                    PathType.WALK -> it.color = convertIntToStr(R.color.WALK)\r\n                    PathType.BUS -> it.color = convertIntToStr(R.color.BUS)\r\n                    PathType.EXPRESSBUS -> it.color = convertIntToStr(R.color.EXPRESSBUS)\r\n                    PathType.SUBWAY -> it.color = convertIntToStr(R.color.SUBWAY)\r\n                    PathType.TRAIN -> it.color = convertIntToStr(R.color.TRAIN)\r\n                }\r\n                it.map = naverMap\r\n            }\r\n            pathOverlayList.add(pathOverlay)\r\n        }\r\n    }\r\n    \r\n    // 색상 값 변환 HEXACODE(#ffffff) -> INT(@ColorInt)\r\n    private fun convertIntToStr(color:Int) : Int {\r\n        return ContextCompat.getColor(mainActivity, color)\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/hansung/sherpa/navigation/Navigation.kt b/app/src/main/java/com/hansung/sherpa/navigation/Navigation.kt
--- a/app/src/main/java/com/hansung/sherpa/navigation/Navigation.kt	(revision 00cb08aa6b6d3ae83e8a8ad8b1448efcf3d596e7)
+++ b/app/src/main/java/com/hansung/sherpa/navigation/Navigation.kt	(date 1719930548234)
@@ -30,12 +30,18 @@
     // [개발]: 시작, 도착 좌표
 
     // KJH
-        private val tempStartLatLng = LatLng(37.642636, 127.835763)
-        val tempEndLatLng = LatLng(37.627448, 126.829388)
+    //private val tempStartLatLng = LatLng(37.642636, 127.835763)
+    //val tempEndLatLng = LatLng(37.627448, 126.829388)
+    //직선
+    private val tempStartLatLng = LatLng(37.643580, 126.833619)
+    val tempEndLatLng = LatLng(37.628587, 126.828838)
+    //코너
+    //private val tempStartLatLng = LatLng(37.645691, 126.833972)
+    //val tempEndLatLng = LatLng(37.652078, 126.842157)
 
     //KMJ
-//    private val tempStartLatLng = LatLng(37.5004198786564, 127.126936754911) // 인천공항 버스 정류소(오금동)
-//    val tempEndLatLng = LatLng(37.6134436427887, 126.926493082645) // 은평청여울수영장
+    //private val tempStartLatLng = LatLng(37.5004198786564, 127.126936754911) // 인천공항 버스 정류소(오금동)
+    //val tempEndLatLng = LatLng(37.6134436427887, 126.926493082645) // 은평청여울수영장
 
 
     // 반드시 지울 것!!
Index: app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hansung.sherpa.deviation\r\n\r\nimport android.content.Context\r\nimport android.content.res.Resources\r\nimport android.graphics.Color\r\nimport android.os.Build\r\nimport android.util.Log\r\nimport android.view.Gravity\r\nimport android.view.LayoutInflater\r\nimport android.widget.Toast\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.databinding.DataBindingUtil\r\nimport com.hansung.sherpa.navigation.Navigation\r\nimport com.hansung.sherpa.R\r\nimport com.hansung.sherpa.StaticValue\r\nimport com.hansung.sherpa.convert.LegRoute\r\nimport com.hansung.sherpa.databinding.AlertBinding\r\nimport com.hansung.sherpa.transit.Station\r\nimport com.hansung.sherpa.transit.TransitRouteRequest\r\nimport com.naver.maps.geometry.LatLng\r\nimport com.naver.maps.geometry.Utmk\r\nimport com.naver.maps.map.NaverMap\r\nimport com.naver.maps.map.overlay.CircleOverlay\r\nimport com.naver.maps.map.overlay.PathOverlay\r\nimport com.naver.maps.map.overlay.PolygonOverlay\r\nimport com.naver.maps.map.overlay.PolylineOverlay\r\nimport kotlin.collections.*\r\nimport kotlin.math.abs\r\nimport kotlin.math.acos\r\nimport kotlin.math.atan2\r\nimport kotlin.math.cos\r\nimport kotlin.math.pow\r\nimport kotlin.math.sin\r\nimport kotlin.math.sqrt\r\n\r\n/**\r\n *  경로를 그리는 인접한 두 좌표와 현재 위치를 정의하는 클래스\r\n *\r\n *  @property Start 구간의 시작 좌표\r\n *  @property End 구간의 끝 좌표\r\n *  @property CurrLocation 현재 사용자의 좌표\r\n */\r\ndata class Section(\r\n    var Start: LatLng,\r\n    var End: LatLng,\r\n    var CurrLocation: LatLng\r\n)\r\n\r\n/**\r\n *  GPS의 세기와 현재 사용자 위치를 정의하는 클래스\r\n *\r\n *  @property Strength GPS의 세기\r\n *  @property Loncation 사용자의 현재 위치\r\n */\r\ndata class StrengthLocation (\r\n    val Strength: String,\r\n    val Location: LatLng\r\n)\r\n\r\n/**\r\n * @property route 그려질 경로 좌표 리스트\r\n * @property navigation RouteControl을 생성한 Navigation 객체\r\n */\r\nclass RouteControl {\r\n\r\n//    경로 이탈 : 10m\r\n//    경로 구간 확인 : 동적\r\n//    GPS 업데이트 시간 : 1.3s\r\n\r\n    /**\r\n     * @param route 이동할 네비게이션 경로\r\n     * @param nowSection route에서 지금 이동하고 있는 경로\r\n     */\r\n    var route : List<LatLng> = emptyList()\r\n    var nowSection = 0\r\n\r\n    /**\r\n     * ※ from, to는 연산을 요구하기 보다 코드를 짧게 유지하기 위해 만든 함수이다. 변수로 만들지 않아도 이용 가능하다. ※\r\n     * @param from 섹션의 시작점. 항상 route[nowSection]\r\n     * @param to 섹션의 도착점. 항상 route[nowSection+1]\r\n     */\r\n    lateinit var from: Utmk\r\n    lateinit var to: Utmk\r\n\r\n    /**\r\n     * 실질적인 이탈 영역의 범위\r\n     *\r\n     * @param froms 섹션의 시작점에서의 이탈 영역\r\n     * @param tos 섹션의 시작점에서의 이탈 영역\r\n     */\r\n    lateinit var froms:Pair<Utmk, Utmk>\r\n    lateinit var tos: Pair<Utmk, Utmk>\r\n\r\n    //---------- <김명준> develop 브랜치 올라갈 시 삭제할 것 ----------\r\n    val polygonOverlay = PolygonOverlay()\r\n    val circle = CircleOverlay()\r\n    //---------- <김명준> 여기까지 ----------\r\n\r\n    /**\r\n     * 현재 섹션을 다음 섹션으로 이동할지 판단하는 함수\r\n     *\r\n     * @param location 현재 내 위치\r\n     * @return to의 도착지 좌표 8m 이내에 진입할 시 true\r\n     */\r\n    fun detectNextSection(location:LatLng):Boolean {\r\n        // 거리를 탐색할 섹션 목적지 좌표\r\n        val destination = route[nowSection+1]\r\n\r\n        // 내 위치에서 목적지까지의 거리\r\n        val distance = location.distanceTo(destination)\r\n\r\n        // 섹션 목적지 도달\r\n        if(distance <= 8) {\r\n            //---------- <김명준> develop 브랜치 올라갈 시 삭제할 것 ----------\r\n            polygonOverlay.map = null\r\n            circle.map = null\r\n            //---------- <김명준> 여기까지 ----------\r\n\r\n            // 다음 섹션 이동\r\n            nowSection++\r\n\r\n            // 섹션 값 재설정\r\n            from = Utmk.valueOf(route[nowSection])\r\n            to = Utmk.valueOf(route[nowSection+1])\r\n\r\n            // 섹션 영역 재설정\r\n            froms = findIntersectionPoints(from)\r\n            tos = findIntersectionPoints(to)\r\n\r\n            //---------- <김명준> develop 브랜치 올라갈 시 삭제할 것 ----------\r\n            val coords = mutableListOf(\r\n                froms.first.toLatLng(),\r\n                froms.second.toLatLng(),\r\n                tos.second.toLatLng(),\r\n                tos.first.toLatLng()\r\n            )\r\n\r\n            polygonOverlay.coords = coords\r\n            polygonOverlay.outlineWidth = 5\r\n            polygonOverlay.outlineColor = Color.RED\r\n            polygonOverlay.color = Color.TRANSPARENT\r\n\r\n            polygonOverlay.coords = coords\r\n            polygonOverlay.map = StaticValue.naverMap\r\n\r\n            circle.center = LatLng(from.toLatLng().latitude, from.toLatLng().longitude)\r\n            circle.outlineWidth = 5\r\n            circle.outlineColor = Color.RED\r\n            circle.color = Color.TRANSPARENT\r\n            circle.radius = 10.0\r\n            circle.map = StaticValue.naverMap\r\n            //---------- <김명준> 여기까지 ----------\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    /**\r\n     * 원과 직선의 교점을 구하는 함수\r\n     * to, from을 지나는 직선의 방정식에 수직인 기울기와 원의 중심 좌표를 갖는 직선과의 교점을 구한다.\r\n     * Pair.first: 직사각형의 왼쪽 꼭짓점 Pair.second: 직사각형의 오른쪽 꼭짓점\r\n     *\r\n     * @param point 원의 중점\r\n     * @return 교점1, 교점2 - Pair() 혹은 val (get1, get2)로 반환 받을 것\r\n     */\r\n    fun findIntersectionPoints(point:Utmk): Pair<Utmk, Utmk> {\r\n        // 교점을 구하는 방정식 Wx^2 + Lx + M = 0\r\n        // 계산 결과 W=m^2+1, L=--2*(a+m*b), M=a^2+b^2-r^2\r\n        // m은 기울기(slope), (a, b)는 원의 중점과 직선이 지나는 한 점(point)\r\n\r\n        val deltaY = to.y - from.y\r\n        val deltaX = to.x - from.x\r\n        // Utmk from과 to의 직선과 수직인 직선 기울기\r\n        val m = -1*deltaX/deltaY\r\n\r\n        // 직선 y = m(x-a)+b\r\n        val a = point.x\r\n        val b = point.y\r\n        val r = 8.0\r\n\r\n        // 원의 방정식 0 = (x-a)^2 + (y-b)^2 - r^2\r\n        // 원과 직선의 교점 방정식 2a(m^2)±sqrt(4(m^2+1)r^2)/2(m^2+1) -> 원본: 2a(m^2)±sqrt(4a^2(m^2+1)^2-4a^2(m^2+1)^2+4(m^2+1)r^2)/2(m^2+1)\r\n        // 자주 사용하는 m^2+1는 L, ±할 sqrt(4(m^2+1)r^2)/2(m^2+1)는 M으로 지정\r\n        // 계산식 = (2aL±M)/(2L)\r\n\r\n        val L = m.pow(2)+1\r\n        val M = sqrt(4*L*r.pow(2))\r\n        val bigPointX = (2*a*L+M)/(2*L)\r\n        val smallPointX = (2*a*L-M)/(2*L)\r\n\r\n        val bigPoint = Utmk(bigPointX, m*(bigPointX-a)+b)\r\n        val smallPoint = Utmk(smallPointX, m*(smallPointX-a)+b)\r\n\r\n        // 방향성에 따라 직사각형의 위치 관계가 달라진다.\r\n        if (deltaY>=0) return Pair(smallPoint,bigPoint)\r\n        else return Pair(bigPoint,smallPoint)\r\n    }\r\n\r\n    /**\r\n     * Utmk 좌표에서 벡터의 스칼라를 구하는 함수\r\n     *\r\n     * @param vector 스칼라 값을 구할 벡터\r\n     * @return 스칼라 값\r\n     */\r\n    fun toScalar(vector:Utmk) = sqrt(vector.x.pow(2)+vector.y.pow(2))\r\n\r\n    /**\r\n     * Utmk 좌표에서 두 벡터의 코사인 값을 구하는 함수\r\n     *\r\n     * @param vector1 첫번째 벡터\r\n     * @param vector2 두번째 벡터\r\n     * @return 코사인 값\r\n     */\r\n    fun getCosine(vector1: Utmk, vector2: Utmk) = (vector1.x * vector2.x + vector1.y * vector2.y) / (toScalar(vector1) * toScalar(vector2))\r\n\r\n    /**\r\n     * 두 벡터 사이의 각도를 구하는 함수이다.\r\n     * 시계 방향으로 각도를 구한다.\r\n     *\r\n     * @param vector1 방향을 정하는 기준 벡터\r\n     * @param vector2 각도를 정하는 벡터\r\n     * @return 두 벡터 사이의 각도\r\n     */\r\n    fun getTheta(vector1: Utmk, vector2: Utmk): Double {\r\n        // 코사인 값 계산\r\n        val cosine = getCosine(vector1, vector2)\r\n        val radian = acos(cosine)\r\n\r\n        val direction = vector1.x*vector2.y - vector1.y*vector2.x\r\n\r\n        var theta = Math.toDegrees(radian)\r\n\r\n        if(direction > 0) theta = 360-theta\r\n\r\n        return theta\r\n    }\r\n\r\n    /**\r\n     * 출발지와 도착지 간의 점과 직선 사이의 거리가 8m 이하인지 확인한다.\r\n     * @param location 내 위치\r\n     * @return 섹션 출발지와 목적지로부터 수직으로 8m 안에 존재한다면 true\r\n     */\r\n    fun isInArea(location: Utmk): Boolean {\r\n\r\n        val (leftFrom, rightFrom) = froms\r\n        val (leftTo, rightTo) = tos\r\n\r\n        val vector1 = Utmk(leftFrom.x - rightFrom.x, leftFrom.y - rightFrom.y)\r\n        val vector2 = Utmk(rightTo.x - rightFrom.x, rightTo.y - rightFrom.y)\r\n        val locationVector = Utmk(location.x - rightFrom.x, location.y - rightFrom.y)\r\n\r\n        val cosine = getCosine(vector1, locationVector)\r\n\r\n        val x = toScalar(locationVector) * cosine\r\n        val y = toScalar(locationVector) * sqrt(1-cosine.pow(2)) // sqrt(1-cosine.pow(2)) = 사인값\r\n\r\n        val angle = getTheta(vector1,locationVector)\r\n\r\n        if(!(angle in 0.0..90.0)) {Log.d(\"explain\", \"angle issue\")}\r\n        if(!(x in 0.0..16.0 && y in 0.0..toScalar(vector2))) {Log.d(\"explain\", \"length issue\")}\r\n\r\n        return x in 0.0..16.0 && y in 0.0..toScalar(vector2) // 직사각형 내부에 내 위치가 존재\r\n                && angle in 0.0..90.0 // 내 위치의 각이 90보다 작아야 함\r\n    }\r\n\r\n    fun detectOutRoute(location:LatLng):Boolean{\r\n        while(detectNextSection(location)){ continue }\r\n\r\n        // 출발지와 내 위치의 거리를 판단한다.\r\n        val distance = location.distanceTo(route[nowSection])\r\n\r\n        // 출발지와 도착지 간의 점과 직선거리가 올바른지 판단한다.\r\n        val user = Utmk.valueOf(location)\r\n        val inArea = isInArea(user)\r\n\r\n        if(distance > 10 && inArea) {Log.d(\"explain\", \"distance issue\")}\r\n        return distance > 10 && !inArea\r\n    }\r\n\r\n    /**\r\n     *  전체 경로 중 벡터 좌표 사이 구간의 사용자 이동 경로를 설정하는 함수\r\n     *\r\n     *  @param section 시작, 끝 벡터 좌표, 현재 사용자 위치를 가져옴\r\n     *  @return PathOverlay\r\n     */\r\n    fun drawProgressLine(section: Section): PathOverlay {\r\n        return PathOverlay().also {\r\n            it.coords = listOf(section.Start, section.CurrLocation)\r\n            it.width = 10\r\n            it.passedColor = Color.YELLOW\r\n            it.progress = 1.0\r\n        }\r\n    }\r\n\r\n    object AlterToast {\r\n        fun createToast(context: Context): Toast? {\r\n            val inflater = LayoutInflater.from(context)\r\n            val binding: AlertBinding = DataBindingUtil.inflate(inflater, R.layout.alert, null, false)\r\n\r\n            return Toast(context).apply {\r\n                setGravity(Gravity.BOTTOM or Gravity.CENTER, 0, 16.toPx())\r\n                duration = Toast.LENGTH_SHORT\r\n                view = binding.root\r\n            }\r\n        }\r\n\r\n        private fun Int.toPx(): Int = (this * Resources.getSystem().displayMetrics.density).toInt()\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt b/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt
--- a/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt	(revision 00cb08aa6b6d3ae83e8a8ad8b1448efcf3d596e7)
+++ b/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt	(date 1719929901995)
@@ -128,6 +128,7 @@
             tos = findIntersectionPoints(to)
 
             //---------- <김명준> develop 브랜치 올라갈 시 삭제할 것 ----------
+            /*
             val coords = mutableListOf(
                 froms.first.toLatLng(),
                 froms.second.toLatLng(),
@@ -148,7 +149,7 @@
             circle.outlineColor = Color.RED
             circle.color = Color.TRANSPARENT
             circle.radius = 10.0
-            circle.map = StaticValue.naverMap
+            circle.map = StaticValue.naverMap*/
             //---------- <김명준> 여기까지 ----------
             return true
         }
Index: app/src/main/java/com/hansung/sherpa/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hansung.sherpa\r\n\r\nimport android.graphics.PointF\r\nimport android.location.Location\r\nimport android.os.Build\r\nimport android.os.Bundle\r\nimport android.util.Log\r\nimport android.widget.EditText\r\nimport android.widget.ImageButton\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport androidx.lifecycle.MutableLiveData\r\nimport androidx.lifecycle.ViewModel\r\nimport androidx.lifecycle.ViewModelProvider\r\nimport com.hansung.sherpa.deviation.RouteControl\r\nimport com.hansung.sherpa.deviation.StrengthLocation\r\nimport com.hansung.sherpa.gps.GPSDatas\r\nimport com.hansung.sherpa.navigation.Navigation\r\nimport com.hansung.sherpa.gps.GpsLocationSource\r\nimport com.hansung.sherpa.navigation.MyOnLocationChangeListener\r\nimport com.hansung.sherpa.navigation.OnLocationChangeManager\r\nimport com.naver.maps.geometry.LatLng\r\nimport com.naver.maps.map.LocationTrackingMode\r\nimport com.naver.maps.map.MapFragment\r\nimport com.naver.maps.map.NaverMap\r\nimport com.naver.maps.map.NaverMapSdk\r\nimport com.naver.maps.map.OnMapReadyCallback\r\nimport com.naver.maps.map.overlay.Marker\r\nimport com.naver.maps.map.overlay.OverlayImage\r\nimport com.naver.maps.map.util.FusedLocationSource\r\n\r\nclass MainActivity : AppCompatActivity(), OnMapReadyCallback {\r\n\r\n    private lateinit var naverMap: NaverMap\r\n\r\n    private val LOCATION_PERMISSION_REQUEST_CODE = 1000\r\n    private lateinit var locationSource: FusedLocationSource\r\n    private lateinit var destinationTextView: EditText // 목적지 textview\r\n    private lateinit var searchButton: ImageButton // 검색 버튼\r\n    private val markerIcon = OverlayImage.fromResource(com.naver.maps.map.R.drawable.navermap_location_overlay_icon)\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        NaverMapSdk.getInstance(this).client =\r\n            NaverMapSdk.NaverCloudPlatformClient(BuildConfig.CLIENT_ID)\r\n\r\n        val fm = supportFragmentManager\r\n        val mapFragment = fm.findFragmentById(R.id.map) as MapFragment?\r\n            ?: MapFragment.newInstance().also {\r\n                fm.beginTransaction().add(R.id.map, it).commit()\r\n            }\r\n\r\n        mapFragment.getMapAsync(this)\r\n\r\n        destinationTextView = findViewById(R.id.destination_editText)\r\n        searchButton = findViewById(R.id.search_button)\r\n\r\n//        locationSource = FusedLocationSource(this, LOCATION_PERMISSION_REQUEST_CODE)\r\n        locationSource = GpsLocationSource.createInstance(this)\r\n    }\r\n\r\n    @RequiresApi(Build.VERSION_CODES.R)\r\n    override fun onMapReady(p0: NaverMap) {\r\n        this.naverMap = p0\r\n        StaticValue.naverMap = naverMap // todo: 임시 바로 삭제할 것(김명준)\r\n\r\n        // LocationOverlay 설정\r\n        val locationOverlay = naverMap.locationOverlay\r\n        locationOverlay.icon = markerIcon\r\n        locationOverlay.isVisible = true\r\n\r\n        //좌측하단 Tracking Mode 변환 버튼\r\n        naverMap.uiSettings.isLocationButtonEnabled = true\r\n        naverMap.locationSource = locationSource\r\n\r\n        // 움직이는 사용자 마커 따라 그리기\r\n        onChangeUserMarker()\r\n\r\n        // 검색어 키워드\r\n        val startKeyword = \"반드시 지우시오!\" // TODO : SearchLocation.kt 완성 시 반드시 수정할 것 !!!\r\n        val endKeyword = destinationTextView.text.toString()\r\n\r\n        // 검색 필요 클래스 초기화\r\n        val routeControl = RouteControl() // 사용자 위치 확인\r\n        val gpsData = GPSDatas(this) // gps 위치\r\n        val navigation = Navigation() // 경로 그리기 & 탐색\r\n        navigation.naverMap = naverMap\r\n        navigation.mainActivity = this\r\n        navigation.routeControl = routeControl\r\n\r\n        // 검색 버튼 클릭 리스너 (출발지, 도착지 검색시 경로 그리기)\r\n        searchButton.setOnClickListener {\r\n            navigation.getTransitRoutes(startKeyword, endKeyword)\r\n        }\r\n\r\n        // ----- 사용자 위치 변경시 경로 이탈 확인 로직 -----\r\n        val i = object : MyOnLocationChangeListener {\r\n            override fun callback(location: Location) {\r\n                val nowLocation = LatLng(location.latitude, location.longitude)\r\n\r\n                if (routeControl.detectOutRoute(nowLocation)) {// 경로이탈 탐지\r\n                    navigation.redrawRoute(nowLocation, navigation.tempEndLatLng)\r\n                }\r\n            }\r\n        }\r\n\r\n        val OLCM = OnLocationChangeManager\r\n        OLCM.naverMap = naverMap\r\n        OLCM.addMyOnLocationChangeListener(i)\r\n        // ----- 경로 이탈 확인 로직 끝 -----\r\n\r\n        // 검색하기 전까지 값을 저장해두기 위한 viewModel이다. searchRoute.kt에 저장되어있다.\r\n        val viewModel = ViewModelProvider(this)[SearchRouteViewModel::class.java]\r\n\r\n        viewModel.destinationText.observe(this) {\r\n            viewModel.destinationText.value = destinationTextView.text.toString()\r\n        }\r\n    }\r\n\r\n    // 사용자 마커 표시\r\n    private fun onChangeUserMarker() {\r\n        val currMarker = Marker()\r\n        naverMap.addOnLocationChangeListener { location ->\r\n            currMarker.map = null\r\n            setUserMarkerPosition(currMarker, LatLng(location.latitude, location.longitude))\r\n        }\r\n    }\r\n\r\n    // 사용자 마커 위치 지정하여 재정의\r\n    private fun setUserMarkerPosition(marker: Marker, latLng: LatLng) {\r\n        marker.icon = markerIcon\r\n        marker.position = latLng\r\n        marker.anchor = PointF(0.5f, 0.5f)\r\n        marker.map = naverMap\r\n    }\r\n\r\n    // 권한 확인\r\n    override fun onRequestPermissionsResult(\r\n        requestCode: Int,\r\n        permissions: Array<String>,\r\n        grantResults: IntArray\r\n    ) {\r\n        if (locationSource.onRequestPermissionsResult(\r\n                requestCode, permissions,\r\n                grantResults\r\n            )\r\n        ) {\r\n            if (!locationSource.isActivated) { // 권한 거부됨\r\n                naverMap.locationTrackingMode = LocationTrackingMode.None\r\n            }\r\n            return\r\n        }\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\r\n    }\r\n}\r\n\r\nclass SearchRouteViewModel: ViewModel() {\r\n    val destinationText = MutableLiveData<String>()\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/hansung/sherpa/MainActivity.kt b/app/src/main/java/com/hansung/sherpa/MainActivity.kt
--- a/app/src/main/java/com/hansung/sherpa/MainActivity.kt	(revision 00cb08aa6b6d3ae83e8a8ad8b1448efcf3d596e7)
+++ b/app/src/main/java/com/hansung/sherpa/MainActivity.kt	(date 1719928732997)
@@ -103,6 +103,7 @@
                 if (routeControl.detectOutRoute(nowLocation)) {// 경로이탈 탐지
                     navigation.redrawRoute(nowLocation, navigation.tempEndLatLng)
                 }
+                Log.d("CurrSectionNum",""+routeControl.nowSection)
             }
         }
 
