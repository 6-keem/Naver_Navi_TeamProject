Index: app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hansung.sherpa.deviation\r\n\r\nimport android.content.Context\r\nimport android.content.res.Resources\r\nimport android.graphics.Color\r\nimport android.os.Build\r\nimport android.util.Log\r\nimport android.view.Gravity\r\nimport android.view.LayoutInflater\r\nimport android.widget.Toast\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.databinding.DataBindingUtil\r\nimport com.hansung.sherpa.navigation.Navigation\r\nimport com.hansung.sherpa.R\r\nimport com.hansung.sherpa.StaticValue\r\nimport com.hansung.sherpa.convert.LegRoute\r\nimport com.hansung.sherpa.databinding.AlertBinding\r\nimport com.hansung.sherpa.transit.Station\r\nimport com.hansung.sherpa.transit.TransitRouteRequest\r\nimport com.naver.maps.geometry.LatLng\r\nimport com.naver.maps.geometry.Utmk\r\nimport com.naver.maps.map.NaverMap\r\nimport com.naver.maps.map.overlay.CircleOverlay\r\nimport com.naver.maps.map.overlay.PathOverlay\r\nimport com.naver.maps.map.overlay.PolygonOverlay\r\nimport com.naver.maps.map.overlay.PolylineOverlay\r\nimport kotlin.collections.*\r\nimport kotlin.math.abs\r\nimport kotlin.math.acos\r\nimport kotlin.math.atan2\r\nimport kotlin.math.cos\r\nimport kotlin.math.pow\r\nimport kotlin.math.sin\r\nimport kotlin.math.sqrt\r\n\r\n/**\r\n *  경로를 그리는 인접한 두 좌표와 현재 위치를 정의하는 클래스\r\n *\r\n *  @property Start 구간의 시작 좌표\r\n *  @property End 구간의 끝 좌표\r\n *  @property CurrLocation 현재 사용자의 좌표\r\n */\r\ndata class Section(\r\n    var Start: LatLng,\r\n    var End: LatLng,\r\n    var CurrLocation: LatLng\r\n)\r\n\r\n/**\r\n *  GPS의 세기와 현재 사용자 위치를 정의하는 클래스\r\n *\r\n *  @property Strength GPS의 세기\r\n *  @property Loncation 사용자의 현재 위치\r\n */\r\ndata class StrengthLocation (\r\n    val Strength: String,\r\n    val Location: LatLng\r\n)\r\n\r\n/**\r\n * @property route 그려질 경로 좌표 리스트\r\n * @property navigation RouteControl을 생성한 Navigation 객체\r\n */\r\nclass RouteControl {\r\n\r\n//    경로 이탈 : 10m\r\n//    경로 구간 확인 : 동적\r\n//    GPS 업데이트 시간 : 1.3s\r\n\r\n    /**\r\n     * @param route 이동할 네비게이션 경로\r\n     * @param nowSection route에서 지금 이동하고 있는 경로\r\n     */\r\n    var route : List<LatLng> = emptyList()\r\n    var nowSection = 0\r\n\r\n    /**\r\n     * ※ from, to는 연산을 요구하기 보다 코드를 짧게 유지하기 위해 만든 함수이다. 변수로 만들지 않아도 이용 가능하다. ※\r\n     * @param from 섹션의 시작점. 항상 route[nowSection]\r\n     * @param to 섹션의 도착점. 항상 route[nowSection+1]\r\n     */\r\n    lateinit var from: Utmk\r\n    lateinit var to: Utmk\r\n\r\n    /**\r\n     * 실질적인 이탈 영역의 범위\r\n     *\r\n     * @param froms 섹션의 시작점에서의 이탈 영역\r\n     * @param tos 섹션의 시작점에서의 이탈 영역\r\n     */\r\n    lateinit var froms:Pair<Utmk, Utmk>\r\n    lateinit var tos: Pair<Utmk, Utmk>\r\n\r\n    //---------- <김명준> develop 브랜치 올라갈 시 삭제할 것 ----------\r\n    val polyline = PolygonOverlay()\r\n    val circle = CircleOverlay()\r\n    //---------- <김명준> 여기까지 ----------\r\n\r\n    /**\r\n     * 현재 섹션을 다음 섹션으로 이동할지 판단하는 함수\r\n     *\r\n     * @param location 현재 내 위치\r\n     * @return to의 도착지 좌표 8m 이내에 진입할 시 true\r\n     */\r\n    fun detectNextSection(location:LatLng):Boolean {\r\n        // 거리를 탐색할 섹션 목적지 좌표\r\n        val destination = route[nowSection+1]\r\n\r\n        // 내 위치에서 목적지까지의 거리\r\n        val distance = location.distanceTo(destination)\r\n\r\n        // 섹션 목적지 도달\r\n        if(distance <= 8) {\r\n            //---------- <김명준> develop 브랜치 올라갈 시 삭제할 것 ----------\r\n            polyline.map = null\r\n            circle.map = null\r\n            //---------- <김명준> 여기까지 ----------\r\n\r\n            // 다음 섹션 이동\r\n            nowSection++\r\n\r\n            // 섹션 값 재설정\r\n            from = Utmk.valueOf(route[nowSection])\r\n            to = Utmk.valueOf(route[nowSection+1])\r\n\r\n            // 섹션 영역 재설정\r\n            froms = findIntersectionPoints(from)\r\n            tos = findIntersectionPoints(to)\r\n\r\n            //---------- <김명준> develop 브랜치 올라갈 시 삭제할 것 ----------\r\n            val coords = mutableListOf(\r\n                froms.first.toLatLng(),\r\n                froms.second.toLatLng(),\r\n                tos.second.toLatLng(),\r\n                tos.first.toLatLng()\r\n            )\r\n\r\n            polyline.coords = coords\r\n            polyline.outlineWidth = 5\r\n            polyline.outlineColor = Color.RED\r\n            polyline.color = Color.TRANSPARENT\r\n\r\n            polyline.coords = coords\r\n            polyline.map = StaticValue.naverMap\r\n\r\n            circle.center = LatLng(from.toLatLng().latitude, from.toLatLng().longitude)\r\n            circle.outlineWidth = 5\r\n            circle.outlineColor = Color.RED\r\n            circle.color = Color.TRANSPARENT\r\n            circle.radius = 10.0\r\n            circle.map = StaticValue.naverMap\r\n            //---------- <김명준> 여기까지 ----------\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    /**\r\n     * 원과 직선의 교점을 구하는 함수\r\n     * to, from을 지나는 직선의 방정식에 수직인 기울기와 원의 중심 좌표를 갖는 직선과의 교점을 구한다.\r\n     * Pair.first: x값이 더 큰 좌표\r\n     *\r\n     * @param point 원의 중점\r\n     * @return 교점1, 교점2 - Pair() 혹은 val (get1, get2)로 반환 받을 것\r\n     */\r\n    fun findIntersectionPoints(point:Utmk): Pair<Utmk, Utmk> {\r\n        // 교점을 구하는 방정식 Wx^2 + Lx + M = 0\r\n        // 계산 결과 W=m^2+1, L=--2*(a+m*b), M=a^2+b^2-r^2\r\n        // m은 기울기(slope), (a, b)는 원의 중점과 직선이 지나는 한 점(point)\r\n\r\n        // Utmk from과 to의 직선과 수직인 직선 기울기\r\n        val m = -1*(from.x - to.x)/(from.y - to.y)\r\n\r\n        // 직선 y = m(x-a)+b\r\n        val a = point.x\r\n        val b = point.y\r\n        val r = 8.0\r\n\r\n        // 원의 방정식 0 = (x-a)^2 + (y-b)^2 - r^2\r\n        // 원과 직선의 교점 방정식 2a(m^2)±sqrt(4(m^2+1)r^2)/2(m^2+1) -> 원본: 2a(m^2)±sqrt(4a^2(m^2+1)^2-4a^2(m^2+1)^2+4(m^2+1)r^2)/2(m^2+1)\r\n        // 자주 사용하는 m^2+1는 L, ±할 sqrt(4(m^2+1)r^2)/2(m^2+1)는 M으로 지정\r\n        // 계산식 = (2aL±M)/(2L)\r\n\r\n        val L = m.pow(2)+1\r\n        val M = sqrt(4*L*r.pow(2))\r\n        val bigPointX = (2*a*L+M)/(2*L)\r\n        val smallPointX = (2*a*L-M)/(2*L)\r\n\r\n        return Pair(Utmk(bigPointX, m*(bigPointX-a)+b), Utmk(smallPointX, m*(smallPointX-a)+b))\r\n    }\r\n\r\n    /**\r\n     * Utmk 좌표에서 벡터의 스칼라를 구하는 함수\r\n     *\r\n     * @param vector 스칼라 값을 구할 벡터\r\n     * @return 스칼라 값\r\n     */\r\n    fun toScalar(vector:Utmk) = sqrt(vector.x.pow(2)+vector.y.pow(2))\r\n\r\n    /**\r\n     * Utmk 좌표에서 두 벡터의 코사인 값을 구하는 함수\r\n     *\r\n     * @param vector1 첫번째 벡터\r\n     * @param vector2 두번째 벡터\r\n     * @return 코사인 값\r\n     */\r\n    fun getCosine(vector1: Utmk, vector2: Utmk) = (vector1.x * vector2.x + vector1.y * vector2.y) / (toScalar(vector1) * toScalar(vector2))\r\n\r\n    /**\r\n     * 두 벡터 사이의 각도를 구하는 함수이다.\r\n     * 시계 방향으로 각도를 구한다.\r\n     *\r\n     * @param vector1 방향을 정하는 기준 벡터\r\n     * @param vector2 각도를 정하는 벡터\r\n     * @return 두 벡터 사이의 각도\r\n     */\r\n    fun getTheta(vector1: Utmk, vector2: Utmk): Double {\r\n        // 코사인 값 계산\r\n        val cosine = getCosine(vector1, vector2)\r\n        var theta = acos(cosine)\r\n\r\n        val direction = vector1.x*vector2.y - vector1.y*vector2.x\r\n\r\n        if(direction < 0) theta = 360-theta\r\n        Log.d(\"explain\", \"${if(direction < 0) \"반시계 방향\" else \"시계 방향\"}\")\r\n\r\n        return theta\r\n    }\r\n\r\n    /**\r\n     * 출발지와 도착지 간의 점과 직선 사이의 거리가 8m 이하인지 확인한다.\r\n     * @param location 내 위치\r\n     * @return 섹션 출발지와 목적지로부터 수직으로 8m 안에 존재한다면 true\r\n     */\r\n    fun isInArea(location: Utmk): Boolean {\r\n\r\n        val (bigFrom, smallFrom) = froms\r\n        val (bigTo, smallTo) = tos\r\n\r\n        val vector1 = Utmk(bigFrom.x - smallFrom.x, bigFrom.y - smallFrom.y)\r\n        val vector2 = Utmk(smallTo.x - smallFrom.x, smallTo.y - smallFrom.y)\r\n        val locationVector = Utmk(location.x - smallFrom.x, location.y - smallFrom.y)\r\n\r\n        val cosine = getCosine(vector1, locationVector)\r\n\r\n        val x = toScalar(locationVector) * cosine\r\n        val y = toScalar(locationVector) * sqrt(1-cosine.pow(2)) // sqrt(1-cosine.pow(2)) = 사인값\r\n\r\n        val angle = getTheta(vector1,locationVector)\r\n        Log.d(\"explain\", \"radian: ${if(angle in 0.0..90.0) \"각도 맞음\" else \"각도 이탈\"} ${angle}\")\r\n        // 포함되는지 판단하고 값의 역으로 리턴\r\n\r\n        Log.d(\"explain\", \"x:${x}, vector1:${16}, y:${y}, vector2:${toScalar(vector2)}\")\r\n        return x in 0.0..16.0 && y in 0.0..toScalar(vector2) // 직사각형 내부에 내 위치가 존재\r\n                && angle in 0.0..90.0 // 내 위치의 각이 90보다 작아야 함\r\n    }\r\n\r\n    fun detectOutRoute(location:LatLng):Boolean{\r\n        while(detectNextSection(location)){ continue }\r\n\r\n        // 출발지와 내 위치의 거리를 판단한다.\r\n        val distance = location.distanceTo(route[nowSection])\r\n\r\n        // 출발지와 도착지 간의 점과 직선거리가 올바른지 판단한다.\r\n        val user = Utmk.valueOf(location)\r\n        val inArea = isInArea(user)\r\n\r\n        Log.d(\"explain\", \"flag: ${if(inArea) \"영역 범위 안\" else \"영역 범위 밖\"}\")\r\n        return distance > 10 && !inArea\r\n    }\r\n\r\n    /**\r\n     *  전체 경로 중 벡터 좌표 사이 구간의 사용자 이동 경로를 설정하는 함수\r\n     *\r\n     *  @param section 시작, 끝 벡터 좌표, 현재 사용자 위치를 가져옴\r\n     *  @return PathOverlay\r\n     */\r\n    fun drawProgressLine(section: Section): PathOverlay {\r\n        return PathOverlay().also {\r\n            it.coords = listOf(section.Start, section.CurrLocation)\r\n            it.width = 10\r\n            it.passedColor = Color.YELLOW\r\n            it.progress = 1.0\r\n        }\r\n    }\r\n\r\n    object AlterToast {\r\n        fun createToast(context: Context): Toast? {\r\n            val inflater = LayoutInflater.from(context)\r\n            val binding: AlertBinding = DataBindingUtil.inflate(inflater, R.layout.alert, null, false)\r\n\r\n            return Toast(context).apply {\r\n                setGravity(Gravity.BOTTOM or Gravity.CENTER, 0, 16.toPx())\r\n                duration = Toast.LENGTH_SHORT\r\n                view = binding.root\r\n            }\r\n        }\r\n\r\n        private fun Int.toPx(): Int = (this * Resources.getSystem().displayMetrics.density).toInt()\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt b/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt
--- a/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt	(revision c81951425aeba4131caf6e3cf2ab17182576e369)
+++ b/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt	(date 1719907412923)
@@ -218,11 +218,12 @@
         // 코사인 값 계산
         val cosine = getCosine(vector1, vector2)
         var theta = acos(cosine)
+        Log.d("각","" + theta)
 
         val direction = vector1.x*vector2.y - vector1.y*vector2.x
 
-        if(direction < 0) theta = 360-theta
-        Log.d("explain", "${if(direction < 0) "반시계 방향" else "시계 방향"}")
+        if(direction > 0) theta = 360-theta
+//        Log.d("explain", "${if(direction < 0) "반시계 방향" else "시계 방향"}")
 
         return theta
     }
