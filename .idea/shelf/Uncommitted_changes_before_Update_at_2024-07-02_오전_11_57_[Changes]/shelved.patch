Index: app/src/main/java/com/hansung/sherpa/navigation/Navigation.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hansung.sherpa.navigation\r\n\r\nimport android.util.Log\r\nimport androidx.core.content.ContextCompat\r\nimport com.hansung.sherpa.MainActivity\r\nimport com.hansung.sherpa.R\r\nimport com.hansung.sherpa.convert.Convert\r\nimport com.hansung.sherpa.convert.LegRoute\r\nimport com.hansung.sherpa.convert.PathType\r\nimport com.hansung.sherpa.deviation.RouteControl\r\nimport com.hansung.sherpa.deviation.Section\r\nimport com.hansung.sherpa.transit.TransitManager\r\nimport com.hansung.sherpa.transit.TransitRouteRequest\r\nimport com.naver.maps.geometry.LatLng\r\nimport com.naver.maps.geometry.Utmk\r\nimport com.naver.maps.map.NaverMap\r\nimport com.naver.maps.map.overlay.PathOverlay\r\nimport kotlinx.coroutines.delay\r\n\r\nclass Navigation {\r\n    private var startLatLng: LatLng = LatLng(0.0, 0.0)\r\n    var endLatLng: LatLng = LatLng(0.0, 0.0)\r\n    private var routeRequest: TransitRouteRequest = setRouteRequest(startLatLng, endLatLng)\r\n    private var pathOverlayList:MutableList<PathOverlay> = mutableListOf()\r\n    lateinit var naverMap: NaverMap\r\n    lateinit var mainActivity: MainActivity\r\n    lateinit var routeControl: RouteControl\r\n\r\n    // 반드시 지울 것!! 좌표 찾기 대신 넣는 임시 값\r\n    // [개발]: 시작, 도착 좌표\r\n    private val tempStartLatLng = LatLng(37.642636, 127.835763)\r\n    val tempEndLatLng = LatLng(37.627448, 126.829388)\r\n\r\n    // 반드시 지울 것!!\r\n    \r\n    // 경로 탐색\r\n    fun getTransitRoutes(start: String, end: String){\r\n        // 검색어 기반 좌표 검색\r\n        /**\r\n         * 미완성이라 주석처리\r\n         * val SL = SearchLocation()\r\n         * startLatLng = SL.searchLatLng(start)\r\n         * endLatLng = SL.searchLatLng(end)\r\n        **/\r\n        \r\n        // 좌표 기반 경로 검색\r\n        routeRequest = setRouteRequest(tempStartLatLng, tempEndLatLng)\r\n        val transitRouteResponse = TransitManager(mainActivity).getTransitRoutes2(routeRequest)\r\n        val transitRoutes = Convert().convertToRouteMutableLists(transitRouteResponse)\r\n        val transitRoute = transitRoutes[0]\r\n        \r\n        // 경로 그리기\r\n        drawRoute(transitRoute)\r\n\r\n        // 기타\r\n        //---------- <김명준> 리팩토링 필요 ----------\r\n        routeControl.route = Convert().convertLegRouteToLatLng(transitRoute)\r\n        routeControl.nowSection = 0\r\n        routeControl.from = Utmk.valueOf(routeControl.route[routeControl.nowSection])\r\n        routeControl.to = Utmk.valueOf(routeControl.route[routeControl.nowSection+1])\r\n        routeControl.froms = routeControl.findIntersectionPoints(routeControl.from)\r\n        routeControl.tos = routeControl.findIntersectionPoints(routeControl.to)\r\n        //---------- 여기까지 ----------\r\n    }\r\n\r\n    // 경로 요청 값 만들기\r\n    private fun setRouteRequest(startLatLng: LatLng, endLatLng: LatLng):TransitRouteRequest {\r\n        return TransitRouteRequest(\r\n            startX = startLatLng.longitude.toString(),\r\n            startY = startLatLng.latitude.toString(),\r\n            endX = endLatLng.longitude.toString(),\r\n            endY = endLatLng.latitude.toString(),\r\n            lang = 0,\r\n            format = \"json\",\r\n            count = 1\r\n        )\r\n    }\r\n\r\n    // 경로를 지우는 함수\r\n    private fun clearRoute() {\r\n        pathOverlayList.forEach { it.map = null }\r\n        pathOverlayList = mutableListOf()\r\n    }\r\n\r\n    // 재탐색 후 경로를 그리는 함수\r\n    fun redrawRoute(location:LatLng, endLatLng: LatLng) {\r\n        // 경로 초기화\r\n        clearRoute()\r\n        // 좌표 기반 경로 검색\r\n        routeRequest = setRouteRequest(location, endLatLng)\r\n        // 요청 좌표 기반 경로 검색\r\n        val transitRouteResponse = TransitManager(mainActivity).getTransitRoutes2(routeRequest)\r\n        val transitRoutes = Convert().convertToRouteMutableLists(transitRouteResponse)\r\n        val transitRoute = transitRoutes[0]\r\n        // 경로 그리기\r\n        drawRoute(transitRoute)\r\n        // 기타\r\n        routeControl.route = Convert().convertLegRouteToLatLng(transitRoute)\r\n        routeControl.nowSection = 0\r\n    }\r\n    \r\n    // 경로를 그리는 함수\r\n    private fun drawRoute(transitRoute: MutableList<LegRoute>) {\r\n        for (i in transitRoute){\r\n            val pathOverlay = PathOverlay().also {\r\n                it.coords = Convert().convertCoordinateToLatLng(i.coordinates)\r\n                it.width = 10\r\n                when(i.pathType){\r\n                    PathType.WALK -> it.color = convertIntToStr(R.color.WALK)\r\n                    PathType.BUS -> it.color = convertIntToStr(R.color.BUS)\r\n                    PathType.EXPRESSBUS -> it.color = convertIntToStr(R.color.EXPRESSBUS)\r\n                    PathType.SUBWAY -> it.color = convertIntToStr(R.color.SUBWAY)\r\n                    PathType.TRAIN -> it.color = convertIntToStr(R.color.TRAIN)\r\n                }\r\n                it.map = naverMap\r\n            }\r\n            pathOverlayList.add(pathOverlay)\r\n        }\r\n    }\r\n    \r\n    // 색상 값 변환 HEXACODE(#ffffff) -> INT(@ColorInt)\r\n    private fun convertIntToStr(color:Int) : Int {\r\n        return ContextCompat.getColor(mainActivity, color)\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/hansung/sherpa/navigation/Navigation.kt b/app/src/main/java/com/hansung/sherpa/navigation/Navigation.kt
--- a/app/src/main/java/com/hansung/sherpa/navigation/Navigation.kt	(revision 5570dd2386337f599f8186e74b2da73131978cb9)
+++ b/app/src/main/java/com/hansung/sherpa/navigation/Navigation.kt	(date 1719843774878)
@@ -28,8 +28,15 @@
 
     // 반드시 지울 것!! 좌표 찾기 대신 넣는 임시 값
     // [개발]: 시작, 도착 좌표
-    private val tempStartLatLng = LatLng(37.642636, 127.835763)
-    val tempEndLatLng = LatLng(37.627448, 126.829388)
+
+    // KJH
+    //    private val tempStartLatLng = LatLng(37.642636, 127.835763)
+    //    val tempEndLatLng = LatLng(37.627448, 126.829388)
+
+    //KMJ
+    private val tempStartLatLng = LatLng(37.5004198786564, 127.126936754911) // 인천공항 버스 정류소(오금동)
+    val tempEndLatLng = LatLng(37.6134436427887, 126.926493082645) // 은평청여울수영장
+
 
     // 반드시 지울 것!!
     
Index: app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hansung.sherpa.deviation\r\n\r\nimport android.content.Context\r\nimport android.content.res.Resources\r\nimport android.graphics.Color\r\nimport android.os.Build\r\nimport android.util.Log\r\nimport android.view.Gravity\r\nimport android.view.LayoutInflater\r\nimport android.widget.Toast\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.databinding.DataBindingUtil\r\nimport com.hansung.sherpa.navigation.Navigation\r\nimport com.hansung.sherpa.R\r\nimport com.hansung.sherpa.StaticValue\r\nimport com.hansung.sherpa.convert.LegRoute\r\nimport com.hansung.sherpa.databinding.AlertBinding\r\nimport com.hansung.sherpa.transit.Station\r\nimport com.hansung.sherpa.transit.TransitRouteRequest\r\nimport com.naver.maps.geometry.LatLng\r\nimport com.naver.maps.geometry.Utmk\r\nimport com.naver.maps.map.NaverMap\r\nimport com.naver.maps.map.overlay.PathOverlay\r\nimport com.naver.maps.map.overlay.PolylineOverlay\r\nimport kotlin.collections.*\r\nimport kotlin.math.abs\r\nimport kotlin.math.acos\r\nimport kotlin.math.atan2\r\nimport kotlin.math.cos\r\nimport kotlin.math.pow\r\nimport kotlin.math.sin\r\nimport kotlin.math.sqrt\r\n\r\n/**\r\n *  경로를 그리는 인접한 두 좌표와 현재 위치를 정의하는 클래스\r\n *\r\n *  @property Start 구간의 시작 좌표\r\n *  @property End 구간의 끝 좌표\r\n *  @property CurrLocation 현재 사용자의 좌표\r\n */\r\ndata class Section(\r\n    var Start: LatLng,\r\n    var End: LatLng,\r\n    var CurrLocation: LatLng\r\n)\r\n\r\n/**\r\n *  GPS의 세기와 현재 사용자 위치를 정의하는 클래스\r\n *\r\n *  @property Strength GPS의 세기\r\n *  @property Loncation 사용자의 현재 위치\r\n */\r\ndata class StrengthLocation (\r\n    val Strength: String,\r\n    val Location: LatLng\r\n)\r\n\r\n/**\r\n * @property route 그려질 경로 좌표 리스트\r\n * @property navigation RouteControl을 생성한 Navigation 객체\r\n */\r\nclass RouteControl {\r\n\r\n//    경로 이탈 : 10m\r\n//    경로 구간 확인 : 동적\r\n//    GPS 업데이트 시간 : 1.3s\r\n\r\n    private var roundRadius = 1.0\r\n    private val outDistance = 10.0\r\n    var route : List<LatLng> = emptyList()\r\n\r\n    /**\r\n     * 사용자와 섹션 사이의 거리 값 m단위 반환\r\n     *\r\n     * @param section 섹션값\r\n     * @param location 사용자 위치\r\n    * */\r\n\r\n    var nowSection = 0\r\n    lateinit var from: Utmk\r\n    lateinit var to: Utmk\r\n    lateinit var froms:Pair<Utmk, Utmk>\r\n    lateinit var tos: Pair<Utmk, Utmk>\r\n\r\n    // 섹션 통과 판단\r\n    fun detectNextSection(location:LatLng):Boolean {\r\n        var distance = 0.0\r\n\r\n        val toLatLng = route[nowSection+1]\r\n\r\n        // 목적지까지의 거리\r\n        distance = location.distanceTo(toLatLng)\r\n\r\n        if(distance <= 8) {\r\n            polyline.map = null\r\n\r\n            nowSection++\r\n\r\n            // 재설정\r\n            from = Utmk.valueOf(route[nowSection])\r\n            to = Utmk.valueOf(route[nowSection+1])\r\n\r\n            froms = findIntersectionPoints(from)\r\n            tos = findIntersectionPoints(to)\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    fun findIntersectionPoints(point:Utmk): Pair<Utmk, Utmk> {\r\n        // 교점을 구하는 방정식 Wx^2 + Lx + M = 0\r\n        // 계산 결과 W=m^2+1, L=--2*(a+m*b), M=a^2+b^2-r^2\r\n        // m은 기울기(slope), (a, b)는 원의 중점과 직선이 지나는 한 점(point)\r\n\r\n        // Utmk from과 to의 직선과 수직인 직선 기울기\r\n        val m = -1*(from.x - to.x)/(from.y - to.y)\r\n\r\n        // 직선 y = m(x-a)+b\r\n        val a = point.x\r\n        val b = point.y\r\n        val r = 8.0\r\n\r\n        // 원의 방정식 0 = (x-a)^2 + (y-b)^2 - r^2\r\n        // 원과 직선의 교점 방정식 2a(m^2)±sqrt(4(m^2+1)r^2)/2(m^2+1) -> 원본: 2a(m^2)±sqrt(4a^2(m^2+1)^2-4a^2(m^2+1)^2+4(m^2+1)r^2)/2(m^2+1)\r\n        // 자주 사용하는 m^2+1는 L, ±할 sqrt(4(m^2+1)r^2)/2(m^2+1)는 M으로 지정\r\n        // 계산식 = (2aL±M)/(2L)\r\n\r\n        val L = m.pow(2)+1\r\n        val M = sqrt(4*L*r.pow(2))\r\n        val bigPointX = (2*a*L+M)/(2*L)\r\n        val smallPointX = (2*a*L-M)/(2*L)\r\n\r\n        return Pair(Utmk(bigPointX, m*(bigPointX-a)+b), Utmk(smallPointX, m*(smallPointX-a)+b))\r\n    }\r\n\r\n    fun toScalar(point:Utmk) = sqrt(point.x.pow(2)+point.y.pow(2))\r\n    fun getCosine(vector1:Utmk, vector2:Utmk) = (vector1.x*vector2.x+vector1.y+vector2.y)/(toScalar(vector1)*toScalar(vector2))\r\n\r\n    // 두 벡터 사이의 각도 계산 함수\r\n    fun angleBetweenVectors(vector1:Utmk, vector2:Utmk): Double {\r\n        // 내적 계산\r\n        val dotProduct = vector1.x * vector2.x + vector1.y * vector2.y\r\n\r\n        // 벡터 크기 계산\r\n        val magnitudeA = sqrt(vector1.x * vector1.y + vector1.y * vector1.y)\r\n        val magnitudeB = sqrt(vector2.x * vector2.y + vector2.y * vector2.y)\r\n\r\n        // 각도 계산 (라디안)\r\n        val theta = acos(dotProduct / (magnitudeA * magnitudeB))\r\n\r\n        // 외적 계산\r\n        val crossProduct = vector1.x * vector2.y - vector1.y * vector2.x\r\n\r\n        // 시계 방향 각도 조정\r\n        return if (crossProduct > 0) {\r\n            2 * Math.PI - theta\r\n        } else {\r\n            theta\r\n        }\r\n    }\r\n\r\n    val polyline = PolylineOverlay()\r\n\r\n    fun checkFlag(location: Utmk): Boolean {\r\n\r\n        //---------- <김명준> develop 브랜치 올라갈 시 삭제할 것 ----------\r\n        val coords = mutableListOf(\r\n            route[nowSection],\r\n            route[nowSection+1],\r\n        )\r\n\r\n        polyline.coords = coords\r\n        polyline.width = 30\r\n        polyline.color = Color.RED\r\n\r\n        polyline.coords = coords\r\n        polyline.map = StaticValue.naverMap\r\n        //---------- <김명준> 여기까지 ----------\r\n\r\n        val (bigFrom, smallFrom) = froms\r\n        val (bigTo, smallTo) = tos\r\n\r\n        val vector1 = Utmk(bigFrom.x - smallFrom.x, bigFrom.y - smallFrom.x)\r\n        val vector2 = Utmk(smallTo.x - smallFrom.x, smallTo.y - smallFrom.x)\r\n        val locationVector = Utmk(location.x - smallFrom.x, location.y - smallFrom.x)\r\n\r\n        // 2. cosine의 주파수를 1/2로 줄인다.\r\n        val cosine = getCosine(vector1, locationVector)\r\n\r\n        val x = toScalar(locationVector) * cosine\r\n        val y = toScalar(locationVector) * sqrt(1-cosine.pow(2))\r\n\r\n        return x > toScalar(vector1) || y > toScalar(vector2) || angleBetweenVectors(vector1,vector2) < -1 || angleBetweenVectors(vector1,vector2) > 91\r\n    }\r\n\r\n    fun detectOutRoute(location:LatLng):Boolean{\r\n        var distance = 0.0\r\n\r\n        while(detectNextSection(location)){ continue }\r\n\r\n        val user = Utmk.valueOf(location)\r\n\r\n        // 출발지 이탈 범위\r\n        distance = location.distanceTo(route[nowSection])\r\n\r\n        // Todo: 점과 직선 간의 거리 영역 제한\r\n        val flag = checkFlag(user)\r\n\r\n        return distance > 10 && flag\r\n    }\r\n\r\n    /**\r\n     *  전체 경로 중 벡터 좌표 사이 구간의 사용자 이동 경로를 설정하는 함수\r\n     *\r\n     *  @param section 시작, 끝 벡터 좌표, 현재 사용자 위치를 가져옴\r\n     *  @return PathOverlay\r\n     */\r\n    fun drawProgressLine(section: Section): PathOverlay {\r\n        return PathOverlay().also {\r\n            it.coords = listOf(section.Start, section.CurrLocation)\r\n            it.width = 10\r\n            it.passedColor = Color.YELLOW\r\n            it.progress = 1.0\r\n        }\r\n    }\r\n\r\n    object AlterToast {\r\n        fun createToast(context: Context): Toast? {\r\n            val inflater = LayoutInflater.from(context)\r\n            val binding: AlertBinding = DataBindingUtil.inflate(inflater, R.layout.alert, null, false)\r\n\r\n            return Toast(context).apply {\r\n                setGravity(Gravity.BOTTOM or Gravity.CENTER, 0, 16.toPx())\r\n                duration = Toast.LENGTH_SHORT\r\n                view = binding.root\r\n            }\r\n        }\r\n\r\n        private fun Int.toPx(): Int = (this * Resources.getSystem().displayMetrics.density).toInt()\r\n    }\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt b/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt
--- a/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt	(revision 5570dd2386337f599f8186e74b2da73131978cb9)
+++ b/app/src/main/java/com/hansung/sherpa/deviation/RouteControl.kt	(date 1719843526153)
@@ -95,6 +95,7 @@
             polyline.map = null
 
             nowSection++
+            Log.d("section",""+nowSection)
 
             // 재설정
             from = Utmk.valueOf(route[nowSection])
